import java.util.*;
public class UglyNumberII {
    /*
    use 3 queues, Q2, Q3, Q5.
    init Q2 with 2. Q3 with 3, Q5 with 5 take the min, Q2 offer min * 2, Q3, Q5 same. 
    since all the combanations are generated from 2, 3 and 5, then duplicate ones: 2 * 4 * 3 == 3 * 4 * 2, happens when larger factor multiply smaller one (number 3 * 4 from 3 but mul by 2. since 2 * 4 < 3 * 4, are already selected and generated by 2 * 3 with it)
    if min is from 2, then mul 2, 3, 5 to each of the queue. if from 3, multiple 3, 5, if from 5, mul 5.
    
    1. all numbers are generated from 2, 3, 5. (other numbers like 4 can be generated from these prime numbers)
    2. find a way to de-dup, e.g. 2 * 3 == 3 * 2.
    3. realize that min from 2 does not mean mul 2,3,5 all to Q2, but distribute them: 2 * 5 > 4 * 2, distribute makes sure things are in sequence regards to 2, 3, 5 in the queue.
    
    anyways, this is not something i could think of clearly in an interview, for now.
    
    corner case, n < 0.
    overflow when multiply by 2, 3, 5
    */
    public int nthUglyNumber(int n) {
        Queue<Long> Q2 = new LinkedList<>(), Q3 = new LinkedList<>(), Q5 = new LinkedList<>();
        Q2.offer(2l);
        Q3.offer(3l);
        Q5.offer(5l);
        long min = 1;
        n--;
        while(n != 0) {
            min = Math.min(Q2.peek(), Math.min(Q3.peek(), Q5.peek()));
            Q5.offer(min * 5);
            if(min == Q2.peek()) {
                Q2.poll();
                Q2.offer(min * 2);
                Q3.offer(min * 3);
            } else if(min == Q3.peek()) {
                Q3.poll();
                Q3.offer(min * 3);
            } else Q5.poll();
            n--;
        }
        return (int) min;
    }
}
